function Get-TargetedMalwareAnalysis {
    param (
        [Parameter(Mandatory=$false)][string]$CsvPath,
        [string]$GlobalResolutionPath = "output\Global_Hash_Resolution.csv",
        [string]$BaselineRootPath = "output-baseline\VirusTotal-main",
        [string]$BaselineBehavePath = "output-baseline\VirusTotal-behaviors",
        [string]$MaliciousStoragePath = "output-baseline\VirusTotal-main\malicious",
        [string]$BehaviorsStoragePath = "output-baseline\VirusTotal-behaviors\malicious",
        # Path set to root output folder as requested
        [string]$NotInVTStoragePath = "output", 
        [int]$MinDetections = 5  # Filter weak samples
    )

    # --- 1. SETUP ---
    if ([string]::IsNullOrWhiteSpace($CsvPath)) { $CsvPath = Read-Host "[?] Input CSV Path" }
    $CsvPath = $CsvPath -replace '"', ''
    if (-not (Test-Path $CsvPath)) { Write-Error "File not found."; return }

    $TargetDir = Split-Path -Path $CsvPath -Parent
    $GlobalDir = Split-Path -Path $GlobalResolutionPath -Parent
    
    # Ensure Directories Exist
    foreach ($path in @($GlobalDir, $MaliciousStoragePath, $BehaviorsStoragePath, $NotInVTStoragePath)) {
        if (-not (Test-Path $path)) { New-Item -ItemType Directory -Path $path -Force | Out-Null }
    }

    Write-Host "Target: $TargetDir" -ForegroundColor Cyan

    # --- 2. LOAD IGNORE LIST (NOT IN VT) ---
    # File will now be at output\MissingHashes.csv
    $NotInVTFile = Join-Path $NotInVTStoragePath "MissingHashes.csv"
    $NotInVTCache = [System.Collections.Generic.HashSet[string]]::new()
    
    if (Test-Path $NotInVTFile) {
        Import-Csv $NotInVTFile | ForEach-Object { [void]$NotInVTCache.Add($_.Hash) }
        Write-Host "Loaded $($NotInVTCache.Count) hashes to IGNORE (Not in VT)." -ForegroundColor Gray
    }

    # --- 3. LOAD & NORMALIZE INPUT ---
    $IocData = Import-Csv -Path $CsvPath
    if (-not $IocData) { return }
    
    $Row1 = $IocData | Select-Object -First 1; $Props = $Row1.PSObject.Properties.Name
    $TypeCol = $Props | Where-Object { $_ -match "IOCType|Type" } | Select-Object -First 1
    $ValCol  = $Props | Where-Object { ($_ -match "IOCValue|IOC") -and ($_ -ne $TypeCol) } | Select-Object -First 1
    $DateCol = $Props | Where-Object { $_ -match "Date" } | Select-Object -First 1

    $InputQueue = @()
    foreach ($row in $IocData) {
        $v = $row.$ValCol
        if ($row.$TypeCol -match "SHA256|MD5|SHA1|Hash" -and -not [string]::IsNullOrWhiteSpace($v)) {
            $d = if ($DateCol -and $row.$DateCol) { $row.$DateCol } else { "1970-01-01" }
            if ($d -match "(\d{4}-\d{2}-\d{2})") { $d = $matches[1] } 
            $InputQueue += [PSCustomObject]@{ Hash=$v; Date=$d }
        }
    }
    $InputQueue = $InputQueue | Sort-Object Hash -Unique
    Write-Host "Found $($InputQueue.Count) unique hashes to process." -ForegroundColor Gray

    # --- 4. LOAD GLOBAL CACHE ---
    $GlobalMap = @{} 
    if (Test-Path $GlobalResolutionPath) {
        Import-Csv $GlobalResolutionPath | ForEach-Object {
            $GlobalMap[$_.Input_Hash] = @{ SHA256=$_.Canonical_SHA256; Date=$_.Date_Found }
        }
        Write-Host "Loaded $($GlobalMap.Count) hashes from Global Resolution Cache." -ForegroundColor Green
    }

    # --- API SETUP ---
    $VTApi = Get-Secret -Name 'VT_API_Key_3' -AsPlainText
    if (-not $VTApi) { Write-Error "Missing VT Key"; return }
    $VT_headers = @{ "x-apikey" = $VTApi; "Content-Type" = "application/json" }

    # --- 5. PROCESSING LOOP (PHASE 1) ---
    Write-Host "`n[Phase 1] Resolving Hashes..." -ForegroundColor Cyan
    $NewEntries = @()
    $QuotaHit = $false
    $ProcessedSHA256 = [System.Collections.Generic.HashSet[string]]::new()
    $TargetDateMap = @{} 

    foreach ($Item in $InputQueue) {
        if ($QuotaHit) { break }
        $Input = $Item.Hash
        $Date  = $Item.Date
        $RealSHA256 = $null

        # [CHECK 1] IS IT IN THE IGNORE LIST?
        if ($NotInVTCache.Contains($Input)) {
            # Skip without API call
            continue
        }

        # [CHECK 2] IS IT RESOLVED LOCALLY?
        if ($GlobalMap.ContainsKey($Input)) {
            $RealSHA256 = $GlobalMap[$Input].SHA256
            if ($Date -eq "1970-01-01" -and $GlobalMap[$Input].Date -ne "1970-01-01") { $Date = $GlobalMap[$Input].Date }
        } else {
            $DiskPath = Join-Path $MaliciousStoragePath "$Input.json"
            if (Test-Path $DiskPath) {
                $RealSHA256 = $Input
            } else {
                # [API CALL] Only happens if NOT in Ignore List and NOT in Local Cache
                Write-Host "  Resolving: $Input" -ForegroundColor Yellow
                try {
                    $r = Invoke-RestMethod -Uri "https://www.virustotal.com/api/v3/files/$Input" -Headers $VT_headers -Method Get
                    $RealSHA256 = $r.data.id
                    if ($Date -eq "1970-01-01") {
                        $ts = $r.data.attributes.first_submission_date
                        if ($ts) { $Date = [DateTimeOffset]::FromUnixTimeSeconds($ts).DateTime.ToString("yyyy-MM-dd") }
                    }
                    $r | ConvertTo-Json -Depth 6 | Set-Content -Path (Join-Path $MaliciousStoragePath "$RealSHA256.json")
                } catch {
                    $code = $_.Exception.Response.StatusCode.value__
                    
                    if ($code -eq 404) {
                        Write-Host "  [404] Not Found in VT. Adding to Ignore List." -ForegroundColor DarkGray
                        
                        # Add to Memory Cache
                        [void]$NotInVTCache.Add($Input)
                        
                        # Add to Disk CSV immediately (Safe Append)
                        $IgnoreEntry = [PSCustomObject]@{ Hash=$Input; DateChecked=(Get-Date).ToString("yyyy-MM-dd") }
                        $IgnoreEntry | Export-Csv -Path $NotInVTFile -Append -NoTypeInformation -Encoding UTF8
                    }
                    elseif ($code -eq 429) { 
                        Write-Host "  [!] Quota Exceeded." -ForegroundColor Red; $QuotaHit = $true; break 
                    }
                }
                Start-Sleep -Milliseconds 500
            }

            if ($RealSHA256) {
                $GlobalMap[$Input] = @{ SHA256=$RealSHA256; Date=$Date }
                $NewEntries += [PSCustomObject]@{ Input_Hash=$Input; Canonical_SHA256=$RealSHA256; Date_Found=$Date }
            }
        }

        # B. QUEUE FOR ANALYSIS
        if ($RealSHA256) {
            [void]$ProcessedSHA256.Add($RealSHA256)
            
            if (-not $TargetDateMap.ContainsKey($RealSHA256)) {
                $TargetDateMap[$RealSHA256] = $Date
            } else {
                if ($Date -gt $TargetDateMap[$RealSHA256]) { $TargetDateMap[$RealSHA256] = $Date }
            }

            # C. BEHAVIOR DOWNLOAD
            $bFile = Join-Path $BehaviorsStoragePath "$RealSHA256.json"
            $bBase = Join-Path $BaselineBehavePath "$RealSHA256.json"
            if (-not (Test-Path $bFile) -and -not (Test-Path $bBase)) {
                Write-Host "   -> Fetching Behavior: $RealSHA256" -ForegroundColor DarkYellow
                try {
                    $url = "https://www.virustotal.com/api/v3/files/$RealSHA256/behaviour_summary"
                    $r = Invoke-RestMethod -Uri $url -Headers $VT_headers -Method Get
                    $r | ConvertTo-Json -Depth 10 | Set-Content -Path $bFile
                } catch { 
                    if ($_.Exception.Response.StatusCode.value__ -eq 429) { $QuotaHit = $true; break } 
                }
                Start-Sleep -Milliseconds 300
            }
        }
    }

    if ($NewEntries.Count -gt 0) {
        $NewEntries | Export-Csv -Path $GlobalResolutionPath -Append -NoTypeInformation -Encoding UTF8
        Write-Host "  [+] Appended $($NewEntries.Count) items to Global Resolution Map." -ForegroundColor Green
    }

    # [NEW: GUARD CLAUSE] Check if we actually have anything valid to analyze
    if ($ProcessedSHA256.Count -eq 0) {
        Write-Host "`n[!] No valid hashes found to analyze (All items were Missing/Ignored or Empty). Skipping Phases 2 & 3." -ForegroundColor Yellow
        return
    }

    # --- 6. DIFFERENTIAL ANALYSIS (PHASE 2) ---
    Write-Host "`n[Phase 2] Analyzing Targets ($($ProcessedSHA256.Count) files)..." -ForegroundColor Cyan
    
    $Base = @{ WinAPI=@{}; Elf=@{}; Sigma=@{}; Yara=@{}; Cert=@{}; Tags=@{}; Mitre=@{}; Mutex=@{}; Reg=@{}; Proc=@{}; MemUrls=@{}; MemDomains=@{}; IdsRules=@{} }
    $Targ = @{ WinAPI=@{}; Elf=@{}; Sigma=@{}; Yara=@{}; Cert=@{}; Tags=@{}; Mitre=@{}; Mutex=@{}; Reg=@{}; Proc=@{}; MemUrls=@{}; MemDomains=@{}; IdsRules=@{} }
    $Maps = @{ WinAPI=@{}; Elf=@{}; Sigma=@{}; Yara=@{}; Cert=@{}; Tags=@{}; Mitre=@{}; Mutex=@{}; Reg=@{}; Proc=@{}; MemUrls=@{}; MemDomains=@{}; IdsRules=@{} }

    function Get-BehaviorAttributes ($Path) {
        if (-not (Test-Path $Path)) { return $null }
        try {
            $json = Get-Content $Path -Raw | ConvertFrom-Json
            if ($json.data -is [array]) { return $json.data[0].attributes } else { return $json.data.attributes } 
        } catch { return $null }
    }

    # A. LOAD BASELINE
    Write-Host "  Loading Enterprise Baseline..." -NoNewline
    $BaseTotal = 0; $BaseFiles = Get-ChildItem -Path $BaselineRootPath -File -Filter "*.json"
    foreach ($file in $BaseFiles) {
        $BaseTotal++
        try {
            $j = Get-Content $file.FullName -Raw | ConvertFrom-Json; $a = $j.data.attributes
            if($a.pe_info.import_list){foreach($d in $a.pe_info.import_list){foreach($f in $d.imported_functions){$k="$($d.library_name)!$f"; if(!$Base.WinAPI[$k]){$Base.WinAPI[$k]=0};$Base.WinAPI[$k]++}}}
            if($a.elf_info.imported_symbols){foreach($s in $a.elf_info.imported_symbols){$k="ELF!$s"; if(!$Base.Elf[$k]){$Base.Elf[$k]=0};$Base.Elf[$k]++}}
            if($a.sigma_analysis_results){foreach($r in $a.sigma_analysis_results){$k=$r.rule_title; if(!$Base.Sigma[$k]){$Base.Sigma[$k]=0};$Base.Sigma[$k]++}}
            if($a.crowdsourced_yara_results){foreach($r in $a.crowdsourced_yara_results){$k=$r.rule_name; if(!$Base.Yara[$k]){$Base.Yara[$k]=0};$Base.Yara[$k]++}}
            if($a.tags){foreach($t in $a.tags){if(!$Base.Tags[$t]){$Base.Tags[$t]=0};$Base.Tags[$t]++}}
            $sig=$a.signature_info; if($sig){$s=if($sig.signers){$sig.signers}elseif($sig.product){$sig.product}else{"Unsigned"};if($s -is [array]){$s=$s -join ", "};$v=if($sig.verified){"Verified"}else{"Unverified"};$k="$s ($v)";if(!$Base.Cert[$k]){$Base.Cert[$k]=0};$Base.Cert[$k]++}else{$k="No Sig";if(!$Base.Cert[$k]){$Base.Cert[$k]=0};$Base.Cert[$k]++}
            
            $bAttr = Get-BehaviorAttributes (Join-Path $BaselineBehavePath "$($file.BaseName).json")
            if ($bAttr) {
                if($bAttr.mitre_attack_techniques){foreach($m in $bAttr.mitre_attack_techniques){$k="$($m.id): $($m.signature_description)"; if(!$Base.Mitre[$k]){$Base.Mitre[$k]=0};$Base.Mitre[$k]++}}
                if($bAttr.mutexes_created){foreach($m in $bAttr.mutexes_created){if(!$Base.Mutex[$m]){$Base.Mutex[$m]=0};$Base.Mutex[$m]++}}
                $rl=@(); if($bAttr.registry_keys_set){$rl+=$bAttr.registry_keys_set}; if($bAttr.registry_keys_opened){$rl+=$bAttr.registry_keys_opened}
                foreach($r in $rl){if(!$Base.Reg[$r]){$Base.Reg[$r]=0};$Base.Reg[$r]++}
                if($bAttr.processes_created){foreach($p in $bAttr.processes_created){if(!$Base.Proc[$p]){$Base.Proc[$p]=0};$Base.Proc[$p]++}}
                if($bAttr.memory_pattern_urls){foreach($u in $bAttr.memory_pattern_urls){if(!$Base.MemUrls[$u]){$Base.MemUrls[$u]=0};$Base.MemUrls[$u]++}}
                if($bAttr.memory_pattern_domains){foreach($d in $bAttr.memory_pattern_domains){if(!$Base.MemDomains[$d]){$Base.MemDomains[$d]=0};$Base.MemDomains[$d]++}}
                if($bAttr.suricata_alerts){foreach($s in $bAttr.suricata_alerts){$k=$s.alert; if(!$Base.IdsRules[$k]){$Base.IdsRules[$k]=0};$Base.IdsRules[$k]++}}
                if($bAttr.snort_alerts){foreach($s in $bAttr.snort_alerts){$k=$s.alert; if(!$Base.IdsRules[$k]){$Base.IdsRules[$k]=0};$Base.IdsRules[$k]++}}
            }
        } catch {}
    }
    Write-Host " Done ($BaseTotal files)." -ForegroundColor Green

    # B. PROCESS TARGETS
    Write-Host "  Processing Targets (Min Detections: $MinDetections)..." -NoNewline
    foreach ($HashSHA256 in $ProcessedSHA256) {
        $file = Join-Path $MaliciousStoragePath "$($HashSHA256).json"
        if (-not (Test-Path $file)) { $file = Join-Path $BaselineRootPath "$($HashSHA256).json" }
        if (-not (Test-Path $file)) { continue }

        try {
            $j = Get-Content $file -Raw | ConvertFrom-Json; $a = $j.data.attributes
            
            # Filter weak detections
            $Score = 0; if ($a.last_analysis_stats.malicious) { $Score = $a.last_analysis_stats.malicious }
            if ($Score -lt $MinDetections) { continue } 
            
            $ObsDate = if ($TargetDateMap.ContainsKey($HashSHA256)) { $TargetDateMap[$HashSHA256] } else { "Unknown" }

            $ctx = [PSCustomObject]@{
                Hash=$HashSHA256; 
                Family=if($a.last_analysis_results.Microsoft.result){$a.last_analysis_results.Microsoft.result}else{"Unknown"}; 
                Name=$a.meaningful_name;
                ObservationDate=$ObsDate
            }

            function Add-Hit($dict, $map, $key, $c) { if(!$dict[$key]){$dict[$key]=0}; $dict[$key]++; if(!$map[$key]){$map[$key]=@()}; $map[$key]+=$c }

            if($a.pe_info.import_list){foreach($d in $a.pe_info.import_list){foreach($f in $d.imported_functions){Add-Hit $Targ.WinAPI $Maps.WinAPI "$($d.library_name)!$f" $ctx}}}
            if($a.elf_info.imported_symbols){foreach($s in $a.elf_info.imported_symbols){Add-Hit $Targ.Elf $Maps.Elf "ELF!$s" $ctx}}
            if($a.sigma_analysis_results){foreach($r in $a.sigma_analysis_results){Add-Hit $Targ.Sigma $Maps.Sigma $r.rule_title $ctx}}
            if($a.crowdsourced_yara_results){foreach($r in $a.crowdsourced_yara_results){Add-Hit $Targ.Yara $Maps.Yara $r.rule_name $ctx}}
            if($a.tags){foreach($t in $a.tags){Add-Hit $Targ.Tags $Maps.Tags $t $ctx}}
            $sig=$a.signature_info; if($sig){$s=if($sig.signers){$sig.signers}elseif($sig.product){$sig.product}else{"Unsigned"};if($s -is [array]){$s=$s -join ", "};$v=if($sig.verified){"Verified"}else{"Unverified"};Add-Hit $Targ.Cert $Maps.Cert "$s ($v)" $ctx}else{Add-Hit $Targ.Cert $Maps.Cert "No Sig" $ctx}
            
            $bPath = Join-Path $BehaviorsStoragePath "$($HashSHA256).json"
            if(-not(Test-Path $bPath)){ $bPath = Join-Path $BaselineBehavePath "$($HashSHA256).json" }
            $bAttr = Get-BehaviorAttributes $bPath
            if ($bAttr) {
                if($bAttr.mitre_attack_techniques){foreach($m in $bAttr.mitre_attack_techniques){Add-Hit $Targ.Mitre $Maps.Mitre "$($m.id): $($m.signature_description)" $ctx}}
                if($bAttr.mutexes_created){foreach($m in $bAttr.mutexes_created){Add-Hit $Targ.Mutex $Maps.Mutex $m $ctx}}
                $rl=@(); if($bAttr.registry_keys_set){$rl+=$bAttr.registry_keys_set}; if($bAttr.registry_keys_opened){$rl+=$bAttr.registry_keys_opened}
                foreach($r in $rl){Add-Hit $Targ.Reg $Maps.Reg $r $ctx}
                if($bAttr.processes_created){foreach($p in $bAttr.processes_created){Add-Hit $Targ.Proc $Maps.Proc $p $ctx}}
                if($bAttr.memory_pattern_urls){foreach($u in $bAttr.memory_pattern_urls){Add-Hit $Targ.MemUrls $Maps.MemUrls $u $ctx}}
                if($bAttr.memory_pattern_domains){foreach($d in $bAttr.memory_pattern_domains){Add-Hit $Targ.MemDomains $Maps.MemDomains $d $ctx}}
                if($bAttr.suricata_alerts){foreach($s in $bAttr.suricata_alerts){Add-Hit $Targ.IdsRules $Maps.IdsRules $s.alert $ctx}}
                if($bAttr.snort_alerts){foreach($s in $bAttr.snort_alerts){Add-Hit $Targ.IdsRules $Maps.IdsRules $s.alert $ctx}}
            }
        } catch {}
    }
    Write-Host " Done." -ForegroundColor Green

    # --- 7. EXPORT ---
    $OutputJsonPath_WinAPI = Join-Path $TargetDir "TargetedAPIDifferentialAnalysis.json"
    $OutputJsonPath_Elf    = Join-Path $TargetDir "TargetedElfDifferentialAnalysis.json"
    $OutputJsonPath_Sigma  = Join-Path $TargetDir "TargetedSigmaDifferentialAnalysis.json"
    $OutputJsonPath_Yara   = Join-Path $TargetDir "TargetedYaraDifferentialAnalysis.json"
    $OutputJsonPath_Cert   = Join-Path $TargetDir "TargetedCertificateDifferentialAnalysis.json"
    $OutputJsonPath_Tags   = Join-Path $TargetDir "TargetedTagsDifferentialAnalysis.json"
    $OutputJsonPath_Mitre  = Join-Path $TargetDir "TargetedMitreDifferentialAnalysis.json"
    $OutputJsonPath_Mutex  = Join-Path $TargetDir "TargetedMutexDifferentialAnalysis.json"
    $OutputJsonPath_Reg    = Join-Path $TargetDir "TargetedRegistryDifferentialAnalysis.json"
    $OutputJsonPath_Proc   = Join-Path $TargetDir "TargetedProcessDifferentialAnalysis.json"
    $OutputJsonPath_MemUrls = Join-Path $TargetDir "TargetedMemoryPatternDifferentialAnalysis.json"
    $OutputJsonPath_MemDoms = Join-Path $TargetDir "TargetedMemoryDomainDifferentialAnalysis.json"
    $OutputJsonPath_Ids     = Join-Path $TargetDir "TargetedIDSDifferentialAnalysis.json"
    $OutputCsvPath          = Join-Path $TargetDir "Targeted_Analysis_Map.csv"
    
    $CsvResults = [System.Collections.Generic.List[PSCustomObject]]::new()

    function Process-Category ($Type, $TDict, $BDict, $Map, $OutPath) {
        $Res = @()
        foreach ($k in $TDict.Keys) {
            $mc=$TDict[$k]; $bc=if($BDict[$k]){$BDict[$k]}else{0}
            $bfRaw = if($BaseTotal-gt 0){$bc/$BaseTotal}else{0}; $bf=[Math]::Round($bfRaw*100,4); $rar=100-$bf
            
            $safeKey = $k
            if ($k -is [PSCustomObject] -or $k -is [System.Collections.Hashtable]) {
                if ($k.key) { 
                    $safeKey = $k.key
                    if ($k.value) { $safeKey = "$($k.key) = $($k.value)" }
                } else { $safeKey = $k | ConvertTo-Json -Depth 1 -Compress }
            }

            $AllDates = $Map[$k] | Select-Object -ExpandProperty ObservationDate -ErrorAction SilentlyContinue
            $MaxDate = ($AllDates | Sort-Object -Descending | Select-Object -First 1)

            $Res += [PSCustomObject]@{ 
                Item_Name=$safeKey; 
                Type=$Type; 
                Baseline_Rarity_Score=$rar; 
                Baseline_Frequency="$bf%"; 
                Baseline_Count=$bc; 
                Malicious_Count=$mc;
                Last_Seen=$MaxDate
            }
            foreach ($f in $Map[$k]) { 
                $CsvResults.Add([PSCustomObject]@{ 
                    Indicator_Type=$Type; 
                    Unique_Item=$safeKey; 
                    File_Hash=$f.Hash; 
                    Malware_Family=$f.Family; 
                    Meaningful_Name=$f.Name; 
                    Baseline_Count=$bc;
                    Last_Observation_Date=$f.ObservationDate
                })
            }
        }
        $Res | Sort-Object Baseline_Rarity_Score -Descending | ConvertTo-Json -Depth 4 | Set-Content $OutPath
    }

    Write-Host "[Phase 3] Saving Results..." -ForegroundColor Cyan
    Process-Category "Windows API" $Targ.WinAPI $Base.WinAPI $Maps.WinAPI $OutputJsonPath_WinAPI
    Process-Category "ELF Symbol"  $Targ.Elf    $Base.Elf    $Maps.Elf    $OutputJsonPath_Elf
    Process-Category "Sigma Rule"  $Targ.Sigma  $Base.Sigma  $Maps.Sigma  $OutputJsonPath_Sigma
    Process-Category "Yara Rule"   $Targ.Yara   $Base.Yara   $Maps.Yara   $OutputJsonPath_Yara
    Process-Category "Certificate" $Targ.Cert   $Base.Cert   $Maps.Cert   $OutputJsonPath_Cert
    Process-Category "VT Tag"      $Targ.Tags   $Base.Tags   $Maps.Tags   $OutputJsonPath_Tags
    Process-Category "MITRE Technique" $Targ.Mitre $Base.Mitre $Maps.Mitre $OutputJsonPath_Mitre
    Process-Category "Mutex"       $Targ.Mutex  $Base.Mutex  $Maps.Mutex  $OutputJsonPath_Mutex
    Process-Category "Registry Key" $Targ.Reg   $Base.Reg    $Maps.Reg    $OutputJsonPath_Reg
    Process-Category "Process"     $Targ.Proc   $Base.Proc   $Maps.Proc   $OutputJsonPath_Proc
    Process-Category "Memory URL"    $Targ.MemUrls    $Base.MemUrls    $Maps.MemUrls    $OutputJsonPath_MemUrls
    Process-Category "Memory Domain" $Targ.MemDomains $Base.MemDomains $Maps.MemDomains $OutputJsonPath_MemDoms
    Process-Category "IDS Rule"      $Targ.IdsRules   $Base.IdsRules   $Maps.IdsRules   $OutputJsonPath_Ids

    if ($CsvResults.Count -gt 0) {
        $CsvResults | Sort-Object Indicator_Type, Unique_Item | Export-Csv -Path $OutputCsvPath -NoTypeInformation -Encoding UTF8
        Write-Host "  Unified CSV Map saved." -ForegroundColor Gray
    }
    Write-Host "Analysis Complete." -ForegroundColor Green
}