# 2025-08-21 version

Param(
    [parameter(Mandatory = $false)]
    [String]$Filter,
    [parameter(Mandatory = $false)]
    [String]$Directory,
    [parameter(Mandatory = $false)]
    [Switch]$Recurse,
    [parameter(Mandatory = $false)]
    [Switch]$Compiled,
    [parameter(Mandatory = $false)]
    [String]$URL,
    [parameter(Mandatory = $false)]
    [Switch]$Files,
    [parameter(Mandatory = $false)]
    [Switch]$Memory,
    [parameter(Mandatory = $false)]
    [string]$OutputPath = "C:\S1_agent\Yara\",
    [parameter(Mandatory = $false)]
    [int]$Days
)

mkdir -Force "C:\S1_agent\Yara"
$date=Get-Date
Write-Output "Start time: $date"
$host_string=Hostname
#$tmpOutPath=$host_string+"_matches.txt"

New-Item -Path $OutputPath -ItemType Directory -Force | Out-Null

if (! (Test-Path -Path $OutputPath -PathType Container)) {
    throw "Output path does not exist."
}

$OutputFileName = "results.json"
$OutputFileNameThreat = "yara_threat_result.json"
$YARA_URL_64 = "http://10.130.69.169/yara/S1-yara_64.exe"
$YARA_URL_32 = "http://10.130.69.169/yara/S1-yara_32.exe"

$ResultsOutputPath = Join-Path -Path $OutputPath -ChildPath $OutputFileName
$ResultsOutputPathThreat = Join-Path -Path $OutputPath -ChildPath $OutputFileNameThreat
$YaraBinaryPath = Join-Path -Path $OutputPath -ChildPath "S1-yara.exe"
$YaraFilePath = Join-Path $OutputPath -ChildPath "rule.yar"
$initial_targets="C:\S1_agent\Yara\initial_targets.txt"
$validated_targets="C:\S1_agent\Yara\validated_targets.txt"
$logfile="C:\S1_agent\Yara\yara.log"
Remove-Item $initial_targets
Remove-Item $validated_targets
Remove-Item $logfile

<#
.SYNOPSIS
    Writes the YARA binary to the set path
#>
function Write-YaraBinary {
    Write-Output "Writing Yara Binary to $($YaraBinaryPath)"
    if ([Environment]::Is64BitOperatingSystem) {
        Write-Output "Using Yara binary for platform: X64 (64 bit)"
        Invoke-WebRequest -Uri $YARA_URL_64 -OutFile $YaraBinaryPath
    }
    else {
        Write-Output "Using Yara binary for platform: X86 (32 bit)"
        Invoke-WebRequest -Uri $YARA_URL_32 -OutFile $YaraBinaryPath
    }
    
    Write-Output "Writing Yara Binary to $($YaraBinaryPath)"
#    Set-Content -Path $YaraBinaryPath -Value $Content -Encoding Byte
}

<#
.SYNOPSIS
    Performs a file scan for the given directory and filter

.PARAMETER Filter
    A file filter specification

.PARAMETER Directory
    A directory specification
#>
function ScanFiles {
    Param(
        [parameter(Mandatory = $false)]
        [String]$Filter,
        [parameter(Mandatory = $true)]
        [String]$Directory,
        [parameter(Mandatory = $false)]
        [Boolean]$Recurse = $false,
        [parameter(Mandatory = $false)]
        [Boolean]$Compiled = $false,
        [parameter(Mandatory = $false)]
        [int]$Days
    )
    Write-Output "Performing file scan: '$($Directory)', filter: '$($Filter)'"

    $opts = @{
        Path    = $Directory
        Filter  = $Filter
        Recurse = $Recurse
        Compiled = $Compiled
        Days = $Days
    }

$files=@()
$hits=@()

if ($Days -eq 0) {
    $earliest_date = (Get-Date).AddDays(-30)
    $Days = 30
    else {
        $earliest_date = (Get-Date).AddDays(-$Days)
    }
}
Write-Output "$((Get-Date).ToString("yyyy-MM-dd HH:mm:ss")): Initialising YARA Scan of $Directory over the last $Days days" > $logfile

Write-Output "$((Get-Date).ToString("yyyy-MM-dd HH:mm:ss")): Identifying initial targets..." >> $logfile
Get-ChildItem -Exclude Windows.db,*.lnk,*.zip,*.desktop.ini,*.pdf,*.tar.gz,*_.DS_Store,*.git*,*.appinfo -Path $Directory -File -Recurse | Where-Object {$_.CreationTime -ge $earliest_date} | Where-Object { $_.length -gt 2048 } | where-Object { $_.length -lt 4000000 } | ForEach-Object { $_.FullName } | Where-Object { $_ -notmatch ".git" } | Where-Object { $_ -notmatch "Windows.db" } | Where-Object { $_ -notmatch ".lnk" } | Where-Object { $_ -notmatch ".zip" } | Where-Object { $_ -notmatch "_.DS_Store" } | Where-Object { $_ -notmatch ".appinfo" } | Where-Object { $_ -notmatch "desktop.ini" } | set-content -path $initial_targets
Write-Output "$((Get-Date).ToString("yyyy-MM-dd HH:mm:ss")): Identifying initial (hidden) targets..." >> $logfile
Get-ChildItem -Hidden -Path $Directory -File -Recurse | Where-Object {$_.CreationTime -ge $earliest_date}  | Where-Object { $_.length -gt 2048 } | where-Object { $_.length -lt 4000000 } | ForEach-Object { $_.FullName } | Where-Object { $_ -notmatch "Windows.db" } | Where-Object { $_ -notmatch ".git" } | Add-Content -Path $initial_targets

#iterate through initial targets to validate they're executable, then populate validated_targets file
$lineCount_initial_targets = (Get-Content $initial_targets | Measure-Object -Line).Lines
$initial_targets_counter = 0

Write-Output "$((Get-Date).ToString("yyyy-MM-dd HH:mm:ss")): Initial targets identified.  Total Initial Targets: $lineCount_initial_targets" >> $logfile
Write-Output "$((Get-Date).ToString("yyyy-MM-dd HH:mm:ss")): Starting target validation process..." >> $logfile

           # Get all file objects
            Get-Content -Path $initial_targets | ForEach-Object {
                if ($PSBoundParameters.ContainsKey('Verbose')) { 
                $initial_targets_counter = $initial_targets_counter + 1
                Write-Output "$((Get-Date).ToString("yyyy-MM-dd HH:mm:ss")): Validating file $initial_targets_counter of $lineCount_initial_targets.  Path: $_" >> $logfile
                }
                # Ensure the file is at least 2 bytes long before attempting to read
                if ($_.Length -lt 2) {
                    return # Skip this file
                }

                $filePath = $_
                $fileStream = $null
                $headerBytes = New-Object byte[] 2

                try {
                    # Open the file and read only the first two bytes for efficiency
                    $fileStream = [System.IO.File]::Open($filePath, 'Open', 'Read', 'Read')
                    $fileStream.Read($headerBytes, 0, 2) | Out-Null

                    # The 'MZ' header is 0x4D 0x5A in hexadecimal
                    # 0x4D is ASCII for 'M'
                    # 0x5A is ASCII for 'Z'
                    if ($headerBytes[0] -eq 0x4D -and $headerBytes[1] -eq 0x5A) {
                        # This file has the MZ header, so output the file object
                        Write-Output $_ >> $validated_targets
                    }
                }
                catch {
                    # Write a warning if a file cannot be accessed (e.g., permissions error)
                    Write-Warning "Could not read file: $filePath. Error: $($_.Exception.Message)"
                }
                finally {
                    # Always close the file stream to release the handle
                    if ($fileStream -ne $null) {
                        $fileStream.Close()
                        $fileStream.Dispose()
                    }
                }
            }

}

# Entry point
if ($Files) {
    if (! $Directory) {
        Throw "When using 'Files' mode, you MUST specify a -Directory parameter to start the search"
    }
}

Write-Output "Init output file"
New-Item -Path $ResultsOutputPath -Force | Out-Null
Remove-Item -Path $ResultsOutputPathThreat -Force 2>&1 | Out-Null
$global:o = @() # output

Write-YaraBinary

if ($URL) {
    if (! $URL -match 'http.*\.yara?') {
        throw "URL '$($URL)' does not end in .yar|.yara, and is not an HTTP/S URL."
    }
    # download rule
    Write-Output "Downloading Yara rule from $($URL)"
    Invoke-WebRequest -Uri $URL -OutFile $YaraFilePath
} else {
    # write default rule
    Write-output "No Rule available"
}

# perform action
if ($Files) {
    ScanFiles -Filter $Filter -Directory $Directory -Recurse $Recurse -Compiled $Compiled
}
if ($Memory) {
    ScanProcesses -Filter $Filter
}

#run YARA against objects in validated_targets:
$lineCount_validated_targets = (Get-Content $validated_targets | Measure-Object -Line).Lines
$validated_targets_counter = 0
Write-Output "$((Get-Date).ToString("yyyy-MM-dd HH:mm:ss")): Validated targets identified.  Total validated targets: $lineCount_validated_targets" >> $logfile
Write-Output "$((Get-Date).ToString("yyyy-MM-dd HH:mm:ss")): Starting YARA Scanning on a total of $lineCount_validated_targets files..." >> $logfile
Get-Content -Path $validated_targets | ForEach-Object {
    if ($PSBoundParameters.ContainsKey('Verbose')) {
    $validated_targets_counter = $validated_targets_counter + 1
    Write-Output "$((Get-Date).ToString("yyyy-MM-dd HH:mm:ss")): Scanning file $validated_targets_counter of $lineCount_validated_targets.  Path: $_" >> $logfile
    }
    $global:output += & $YaraBinaryPath -p 1 -w -f $YaraFilePath $_ >> $ResultsOutputPath
}


if (($global | measure-object -line).lines -ge 1)
{
    ConvertTo-JSON -InputObject $global | Out-File -FilePath $ResultsOutputPathThreat -Append -Force
}

$detections = (Get-Content $ResultsOutputPath | Measure-Object -Line).Lines
Write-Output "$((Get-Date).ToString("yyyy-MM-dd HH:mm:ss")): YARA scanning completed.  $detections potentially infected files were found" >> $logfile
#$FilteredOutput = get-content $ResultsOutputPath | Where-Object { $_ -notmatch "pw_regex2" } | Where-Object { $_ -notmatch "pw_regex3" } | Where-Object { $_ -notmatch "pw_regex4" } | Where-Object { $_ -notmatch "pw_regex5" } 

#encrypt FilteredOutput

#$SHAbytes = [System.Text.Encoding]::UTF8.GetBytes($host_string)
#$sha256 = [System.Security.Cryptography.SHA256]::Create()
#$hashBytes = $sha256.ComputeHash($SHAbytes)
#$hashString = -join ($hashBytes | ForEach-Object { $_.ToString("x2") })
#$KeyValue = $hashString.Substring(0, [Math]::Min($hashString.Length, 16))
#$KeyValue = $KeyValue.ToLower()
#$BytesFiltered = [System.Text.Encoding]::UTF8.GetBytes($FilteredOutput)
#$base64Filtered =[Convert]::ToBase64String($BytesFiltered)
#$encryptedText = ConvertTo-SecureString $base64Filtered -AsPlainText -Force | ConvertFrom-SecureString -Key ($KeyValue.ToCharArray() | % {[byte]$_})

#Set-Content -Path $ResultsOutputPath -Value $FilteredOutput
#Set-Content -Path $ResultsOutputPath -Value $encryptedText

$yara_result = get-content  -Raw  $ResultsOutputPath 
#Set-Content -Path $ResultsOutputPath -Value $yara_result
$Bytes = [System.Text.Encoding]::UTF8.GetBytes($yara_result)
$EncodedText =[Convert]::ToBase64String($Bytes)
$postParams = @{data=$EncodedText;username=$host_string;os="win";scan="yara"}
Invoke-WebRequest -erroraction 'silentlycontinue' -Uri http://10.130.69.169:8080 -Method POST -Body $postParams


Remove-Item -Path $YaraBinaryPath -Force 2>&1 | Out-Null
Remove-Item -Path $YaraFilePath -Force 2>&1 | Out-Null
# Remove-Item -Path $TempOutputPath -Force 2>&1 | Out-Null
$date=Get-Date
Write-Output "End time: $date"