<#
.Module Name
    MalwareDetonation
.SYNOPSIS
    Automated malware execution engine for isolated sandboxes with reporting.
.DESCRIPTION
    Handles "Just-in-Time" renaming and execution of extension-less VirusTotal samples.
    Supports DLLs (via rundll32), Scripts (VBS/JS/PS1 via engines), and EXEs.
    Generates a 'Detonation_Report.csv' detailing successes and failures.
#>

function Invoke-MalwareDetonation {
    <#
    .SYNOPSIS
        Mass-executes malware samples with failure reporting.
    
    .DESCRIPTION
        WARNING: THIS SCRIPT LAUNCHES LIVE MALWARE. RUN ONLY IN AN ISOLATED VM.
        
        1. Scans a target folder.
        2. Reads 'dll_entrypoints.csv' to handle DLL exports.
        3. FILE SNIFFING: Inspects file headers to distinguish Scripts from EXEs.
        4. Auto-Renames files.
        5. Detonates using the correct engine.
        6. REPORTING: Outputs a CSV log and prints a failure summary.

    .PARAMETER SamplesDir
        The folder containing the unzipped malware samples.

    .PARAMETER DllCsvPath
        Optional. The path to the .dll_entrypoints.csv generated by the downloader.
        If not provided, script attempts to find it automatically in the parent folder.

    .PARAMETER ExecutionDelay
        Seconds to pause between launching samples.
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$SamplesDir,

        [Parameter(Mandatory=$false)]
        [string]$DllCsvPath,

        [int]$ExecutionDelay = 10
    )

    # --- 0. SAFETY CHECK ---
    $Confirm = Read-Host "WARNING: You are about to execute LIVE MALWARE in '$SamplesDir'. Type 'YES' to proceed"
    if ($Confirm -ne "YES") { Write-Warning "Aborted."; return }

    if (-not (Test-Path $SamplesDir)) { Write-Error "Folder not found: $SamplesDir"; return }
    $SamplesDir = (Resolve-Path $SamplesDir).Path

    # --- 1. SETUP DLL MAP ---
    $DllMap = @{}
    
    if ([string]::IsNullOrWhiteSpace($DllCsvPath)) {
        $PotentialCsv = Join-Path (Split-Path $SamplesDir -Parent) "*.dll_entrypoints.csv"
        $Found = Get-ChildItem $PotentialCsv -ErrorAction SilentlyContinue | Select-Object -First 1
        if ($Found) { $DllCsvPath = $Found.FullName }
    }

    if (Test-Path $DllCsvPath) {
        Write-Host "Loaded DLL Entry Points from: $(Split-Path $DllCsvPath -Leaf)" -ForegroundColor Cyan
        Import-Csv $DllCsvPath | ForEach-Object {
            $Hash = $_.sha256.Trim()
            if (-not [string]::IsNullOrWhiteSpace($_.entry_point)) {
                $DllMap[$Hash] = $_.entry_point
            } else {
                if (-not $DllMap.ContainsKey($Hash)) { $DllMap[$Hash] = "Control_RunDLL" }
            }
        }
    }

    # --- 2. FILE TYPE SNIFFER ---
    function Get-FileTypeGuess ($FilePath) {
        try {
            $Bytes = Get-Content $FilePath -Encoding Byte -TotalCount 2 -ErrorAction SilentlyContinue
            if ($Bytes.Count -ge 2 -and $Bytes[0] -eq 0x4D -and $Bytes[1] -eq 0x5A) { return "PE" }

            $Text = Get-Content $FilePath -TotalCount 10 -ErrorAction SilentlyContinue
            $Content = $Text -join "`n"
            
            if ($Content -match "<job" -or $Content -match "WScript") { return "WSF" }
            if ($Content -match "Sub " -or $Content -match "Dim " -or $Content -match "CreateObject") { return "VBS" }
            if ($Content -match "var " -or $Content -match "function " -or $Content -match "ActiveXObject") { return "JS" }
            if ($Content -match "Get-Command" -or $Content -match "Invoke-" -or $Content -match "param\(") { return "PS1" }
            if ($Content -match "@echo" -or $Content -match "goto ") { return "BAT" }
            if ($Content -match "import " -or $Content -match "def ") { return "PY" }
            
            return "UNKNOWN"
        } catch { return "UNKNOWN" }
    }

    # --- 3. GATHER FILES ---
    $Files = Get-ChildItem -Path $SamplesDir -File | Where-Object { $_.Extension -notin @(".txt", ".json", ".csv", ".zip", ".stats") }
    
    Write-Host "Found $($Files.Count) potential samples." -ForegroundColor Yellow
    
    # Initialize Report List
    $Report = [System.Collections.Generic.List[PSCustomObject]]::new()

    Write-Host "Starting Execution Loop..." -ForegroundColor Gray
    Start-Sleep -Seconds 2

    # --- 4. EXECUTION LOOP ---
    foreach ($File in $Files) {
        $Hash = $File.BaseName
        $CurrentPath = $File.FullName
        $Extension = $File.Extension.ToLower()
        
        # Track status for this file
        $Status = "Success"
        $ErrorDetail = "None"
        $EngineUsed = "Direct"
        $DetectedType = "Existing Ext"

        # --- A. PREPARE FILE (RENAME IF NEEDED) ---
        if ([string]::IsNullOrWhiteSpace($Extension)) {
            
            if ($DllMap.ContainsKey($Hash)) {
                $DetectedType = "DLL (Known)"
                $TypeGuess = "DLL"
            } else {
                $TypeGuess = Get-FileTypeGuess -FilePath $CurrentPath
                $DetectedType = "Sniffed: $TypeGuess"
            }

            $NewExt = switch ($TypeGuess) {
                "DLL" { ".dll" }
                "PE"  { ".exe" } 
                "VBS" { ".vbs" }
                "JS"  { ".js" }
                "WSF" { ".wsf" }
                "PS1" { ".ps1" }
                "BAT" { ".bat" }
                "PY"  { ".py" }
                Default { ".exe" }
            }

            $NewName = "$Hash$NewExt"
            $NewPath = Join-Path $File.DirectoryName $NewName
            try {
                Rename-Item -Path $CurrentPath -NewName $NewName -Force -ErrorAction Stop
                $CurrentPath = $NewPath
                $Extension = $NewExt
                Write-Host "  [RENAMED] $Hash -> $NewExt ($DetectedType)" -ForegroundColor DarkGray
            } catch {
                $Status = "Failed Rename"
                $ErrorDetail = $_.Exception.Message
                Write-Host "  [ERROR] Could not rename file: $ErrorDetail" -ForegroundColor Red
            }
        }

        # --- B. EXECUTE ---
        if ($Status -eq "Success") {
            Write-Host "Detonating: $(Split-Path $CurrentPath -Leaf)" -NoNewline

            try {
                if ($Extension -eq ".dll") {
                    $EngineUsed = "Rundll32"
                    $EntryPoint = "Control_RunDLL"
                    if ($DllMap.ContainsKey($Hash)) { $EntryPoint = $DllMap[$Hash] }
                    
                    Start-Process "rundll32.exe" -ArgumentList "`"$CurrentPath`",$EntryPoint" -ErrorAction Stop
                    Write-Host " [DLL LAUNCHED] ($EntryPoint)" -ForegroundColor Green

                } elseif ($Extension -match "\.(vbs|js|wsf)") {
                    $EngineUsed = "CScript"
                    Start-Process "cscript.exe" -ArgumentList "`"$CurrentPath`"" -ErrorAction Stop
                    Write-Host " [SCRIPT LAUNCHED]" -ForegroundColor Yellow

                } elseif ($Extension -match "\.(bat|cmd)") {
                    $EngineUsed = "CMD"
                    Start-Process "cmd.exe" -ArgumentList "/c `"$CurrentPath`"" -ErrorAction Stop
                    Write-Host " [BATCH LAUNCHED]" -ForegroundColor Yellow

                } elseif ($Extension -match "\.ps1") {
                    $EngineUsed = "PowerShell"
                    Start-Process "powershell.exe" -ArgumentList "-ExecutionPolicy Bypass -File `"$CurrentPath`"" -ErrorAction Stop
                    Write-Host " [PS1 LAUNCHED]" -ForegroundColor Yellow

                } elseif ($Extension -eq ".py") {
                    # Python check
                    if (Get-Command "python" -ErrorAction SilentlyContinue) {
                        $EngineUsed = "Python"
                        Start-Process "python" -ArgumentList "`"$CurrentPath`"" -ErrorAction Stop
                        Write-Host " [PYTHON LAUNCHED]" -ForegroundColor Yellow
                    } else {
                        throw "Python runtime not found in PATH."
                    }

                } else {
                    # EXE
                    $EngineUsed = "Direct EXE"
                    Start-Process $CurrentPath -ErrorAction Stop
                    Write-Host " [EXE LAUNCHED]" -ForegroundColor Green
                }
            } catch {
                $Status = "Failed Exec"
                $ErrorDetail = $_.Exception.Message
                Write-Host " [FAILED]" -ForegroundColor Red
                Write-Warning "  $ErrorDetail"
            }
        }

        # --- C. LOGGING ---
        $Report.Add([PSCustomObject]@{
            FileName      = $(Split-Path $CurrentPath -Leaf)
            Hash          = $Hash
            DetectedType  = $DetectedType
            Engine        = $EngineUsed
            Status        = $Status
            ErrorDetails  = $ErrorDetail
            Timestamp     = (Get-Date).ToString("HH:mm:ss")
        })

        if ($ExecutionDelay -gt 0) { Start-Sleep -Seconds $ExecutionDelay }
    }

    # --- 5. REPORTING ---
    $ReportPath = Join-Path $SamplesDir "Detonation_Report.csv"
    $Report | Export-Csv -Path $ReportPath -NoTypeInformation
    
    Write-Host "`n--- Execution Summary ---" -ForegroundColor Cyan
    Write-Host "Total Samples: $($Report.Count)"
    Write-Host "Successful:    $(($Report | Where {$_.Status -eq 'Success'}).Count)" -ForegroundColor Green
    
    $Failures = $Report | Where-Object { $_.Status -ne "Success" }
    if ($Failures) {
        Write-Host "Failures:      $($Failures.Count)" -ForegroundColor Red
        Write-Host "`n[!] Failed Samples Feedback:" -ForegroundColor Yellow
        $Failures | Select-Object FileName, DetectedType, ErrorDetails | Format-Table -AutoSize
    } else {
        Write-Host "Failures:      0" -ForegroundColor Green
    }

    Write-Host "`nDetailed report saved to: $ReportPath" -ForegroundColor Gray
}

Export-ModuleMember -Function Invoke-MalwareDetonation