<#
.Module Name
    MalwareDetonation
.SYNOPSIS
    Automated malware execution engine (v21.2 - .NET Speed Edition).
.DESCRIPTION
    UPDATED:
    - SPEED: Replaced Expand-Archive with [System.IO.Compression.ZipFile] (10x faster).
    - DEEP RECURSION: Loops until ALL nested zips (zips inside zips) are extracted and flattened.
    - PDF DETONATION: Prioritizes Adobe Acrobat.
    - TOXIC BROWSER: Bypasses Red Screens.
#>

function Invoke-MalwareDetonation {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$SamplesDir,

        [Parameter(Mandatory=$false)]
        [string]$DllCsvPath,

        [int]$ExecutionDelay = 10,
        [int]$MaxLinksPerFile = 25, 
        [switch]$SimulateClicks = $true
    )

    $Confirm = Read-Host "WARNING: You are about to execute LIVE MALWARE. Type 'YES' to proceed"
    if ($Confirm -ne "YES") { Write-Warning "Aborted."; return }

    if (-not (Test-Path $SamplesDir)) { Write-Error "Folder not found: $SamplesDir"; return }
    $SamplesDir = (Resolve-Path $SamplesDir).Path

    # Load .NET Compression Assemblies
    Add-Type -AssemblyName System.IO.Compression.FileSystem

    # --- 1. SETUP EXECUTABLES ---
    # Browser (Toxic Mode)
    $ChromePath = "C:\Program Files\Google\Chrome\Application\chrome.exe"
    $EdgePath = "C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe"
    $BrowserBin = $null
    $BrowserFlags = @("--ignore-certificate-errors", "--disable-client-side-phishing-detection", "--disable-popup-blocking", "--allow-running-insecure-content", "--no-first-run", "--disable-extensions")

    if (Test-Path $ChromePath) { $BrowserBin = $ChromePath } elseif (Test-Path $EdgePath) { $BrowserBin = $EdgePath }

    # PDF Reader (Adobe Acrobat)
    $AcroPath = $null
    $PossibleAcro = @(
        "C:\Program Files\Adobe\Acrobat DC\Acrobat\Acrobat.exe",
        "C:\Program Files (x86)\Adobe\Acrobat DC\Acrobat\Acrobat.exe",
        "C:\Program Files (x86)\Adobe\Acrobat Reader DC\Reader\AcroRd32.exe"
    )
    foreach ($P in $PossibleAcro) { if (Test-Path $P) { $AcroPath = $P; break } }
    
    if ($AcroPath) { 
        Write-Host "PDF Engine: Adobe Acrobat (Targeting Macros)" -ForegroundColor Cyan 
        try { New-ItemProperty -Path "HKCU:\Software\Adobe\Acrobat Reader\DC\Privileged" -Name "bProtectedMode" -Value 0 -PropertyType DWORD -Force -ErrorAction SilentlyContinue | Out-Null } catch {}
    } else { Write-Host "PDF Engine: Browser (Warning: Macros won't run)" -ForegroundColor Red }

    # --- 2. FAST RECURSIVE UNZIP ---
    Write-Host "`n[Phase 1] Recursively Extracting Archives (.NET Mode)..." -ForegroundColor Cyan
    
    $UnzipCount = 0
    $MaxDepth = 10 # Safety break
    $Depth = 0

    # Loop until no ZIPs exist (Handles Zip-inside-Zip-inside-Zip)
    while ($true) {
        $Zips = Get-ChildItem -Path $SamplesDir -Filter "*.zip" -Recurse
        if ($Zips.Count -eq 0) { break }
        if ($Depth -ge $MaxDepth) { Write-Warning "Max Zip Recursion Depth Reached."; break }

        foreach ($Zip in $Zips) {
            try {
                $Dest = Join-Path $Zip.DirectoryName ($Zip.BaseName + "_extracted")
                
                # .NET Extraction (Fast)
                if (Test-Path $Dest) { Remove-Item $Dest -Recurse -Force -ErrorAction SilentlyContinue }
                [System.IO.Compression.ZipFile]::ExtractToDirectory($Zip.FullName, $Dest)
                
                # Flatten: Move files out to Root
                Get-ChildItem -Path $Dest -Recurse -File | ForEach-Object {
                    $NewName = $_.Name
                    # Collision Handler
                    if (Test-Path (Join-Path $SamplesDir $NewName)) { $NewName = "$($_.BaseName)_$(Get-Random).$($_.Extension)" }
                    Move-Item -Path $_.FullName -Destination (Join-Path $SamplesDir $NewName) -Force -ErrorAction SilentlyContinue
                }
                
                # Cleanup
                Remove-Item -Path $Dest -Recurse -Force -ErrorAction SilentlyContinue
                Remove-Item -Path $Zip.FullName -Force -ErrorAction SilentlyContinue # Delete zip so we don't process it again
                $UnzipCount++
            } catch {
                Write-Warning "Failed to unzip $($Zip.Name): $($_.Exception.Message)"
                # Rename failed zip to .badzip so loop doesn't get stuck
                Rename-Item -Path $Zip.FullName -NewName ($Zip.Name + ".bad") -Force -ErrorAction SilentlyContinue
            }
        }
        $Depth++
    }
    if ($UnzipCount -gt 0) { Write-Host "  Extracted and flattened $UnzipCount archives." -ForegroundColor Green }

    # --- 3. SHELLCODE RUNNER SETUP ---
    if (-not ([System.Management.Automation.PSTypeName]'Shellcode').Type) {
        $Code = @"
        using System;
        using System.Runtime.InteropServices;
        public class Shellcode {
            [DllImport("kernel32.dll")] public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
            [DllImport("kernel32.dll")] public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
            [DllImport("kernel32.dll")] public static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
            public static void Run(byte[] shellcode) {
                IntPtr funcAddr = VirtualAlloc(IntPtr.Zero, (uint)shellcode.Length, 0x1000, 0x40);
                Marshal.Copy(shellcode, 0, funcAddr, shellcode.Length);
                IntPtr hThread = CreateThread(IntPtr.Zero, 0, funcAddr, IntPtr.Zero, 0, IntPtr.Zero);
                WaitForSingleObject(hThread, 4000); 
            }
        }
"@
        Add-Type -TypeDefinition $Code -Language CSharp
    }

    function Invoke-SacrificialShellcode ($FilePath) {
        $Job = Start-Job -ScriptBlock {
            param($Path)
            $Code = @"
            using System;
            using System.Runtime.InteropServices;
            public class Shellcode {
                [DllImport("kernel32.dll")] public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
                [DllImport("kernel32.dll")] public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
                [DllImport("kernel32.dll")] public static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
                public static void Run(byte[] shellcode) {
                    IntPtr funcAddr = VirtualAlloc(IntPtr.Zero, (uint)shellcode.Length, 0x1000, 0x40);
                    Marshal.Copy(shellcode, 0, funcAddr, shellcode.Length);
                    IntPtr hThread = CreateThread(IntPtr.Zero, 0, funcAddr, IntPtr.Zero, 0, IntPtr.Zero);
                    WaitForSingleObject(hThread, 4000); 
                }
            }
"@
            Add-Type -TypeDefinition $Code -Language CSharp
            try { [Shellcode]::Run((Get-Content $Path -Encoding Byte -ReadCount 0)); return "Executed" } catch { return "Error" }
        } -ArgumentList $FilePath
        Wait-Job $Job -Timeout 6 | Out-Null; $Res = Receive-Job $Job; Stop-Job $Job; Remove-Job $Job
        return ($Res -eq "Executed")
    }

    # --- 4. EXECUTION LOOP ---
    Write-Host "`n[Phase 2] Sorting & Detonating..." -ForegroundColor Cyan
    $Files = Get-ChildItem -Path $SamplesDir -File | Where-Object { $_.Extension -notin @(".txt", ".json", ".csv", ".stats", ".bad") } | 
             Sort-Object @{Expression={
                switch -Regex ($_.Extension) {
                    "\.(exe|dll|ps1|bin)$" { 1 }
                    "\.(js|vbs|wsf)$"      { 2 }
                    "\.(html|htm|pdf)$"    { 3 }
                    Default                { 4 }
                }
             }}

    $Report = [System.Collections.Generic.List[PSCustomObject]]::new()
    $DllMap = @{} # Load CSV if needed

    foreach ($File in $Files) {
        $Hash = $File.BaseName
        $CurrentPath = $File.FullName
        $Extension = $File.Extension.ToLower()
        $Status = "Success"; $ErrorDetail = "None"; $EngineUsed = "Direct"

        # A. RENAME / SNIFF
        if ([string]::IsNullOrWhiteSpace($Extension) -or $Extension -eq ".bin") {
             $Bytes = Get-Content $CurrentPath -Encoding Byte -TotalCount 50 -ErrorAction SilentlyContinue
             $Hex = ($Bytes | ForEach-Object { $_.ToString("X2") }) -join " "
             if ($Hex -match "^4D 5A") { $Extension = ".exe" } 
             elseif ($Hex -match "^25 50 44 46") { $Extension = ".pdf" }
        }

        # B. DETONATE
        if ($Status -eq "Success") {
            try {
                # 1. EXE / DLL
                if ($Extension -eq ".exe") {
                    $EngineUsed = "Direct EXE"; Start-Process $CurrentPath -ErrorAction Stop
                } elseif ($Extension -eq ".dll") {
                    $EngineUsed = "Rundll32"; Start-Process "rundll32.exe" -ArgumentList "`"$CurrentPath`",Control_RunDLL" -ErrorAction Stop
                
                # 2. PDF (ADOBE FORCE)
                } elseif ($Extension -eq ".pdf") {
                    if ($AcroPath) {
                        $EngineUsed = "Adobe Acrobat (Macro)"
                        Start-Process $AcroPath -ArgumentList "`"$CurrentPath`"" -ErrorAction Stop
                    } else {
                        $EngineUsed = "Browser (Fallback)"
                        if ($BrowserBin) { Start-Process $BrowserBin -ArgumentList ($BrowserFlags + "`"$CurrentPath`"") -ErrorAction SilentlyContinue }
                    }
                    if ($SimulateClicks) { Invoke-UrlVisits -FilePath $CurrentPath }

                # 3. HTML (TOXIC BROWSER)
                } elseif ($Extension -match "\.(html|htm)") {
                    $EngineUsed = "Browser (Toxic)"
                    if ($BrowserBin) { Start-Process $BrowserBin -ArgumentList ($BrowserFlags + "`"$CurrentPath`"") -ErrorAction SilentlyContinue }
                    if ($SimulateClicks) { Invoke-UrlVisits -FilePath $CurrentPath }

                # 4. SCRIPTS (CSCRIPT)
                } elseif ($Extension -match "\.(js|vbs|wsf)") {
                    $EngineUsed = "CScript (Forced)"
                    Start-Process "cscript.exe" -ArgumentList "//nologo", "//E:JScript", "`"$CurrentPath`"" -ErrorAction Stop

                # 5. SHELLCODE
                } elseif ($Extension -eq ".bin") {
                    $Bytes = Get-Content $CurrentPath -Encoding Byte -ReadCount 0
                    if (-not ([System.Text.Encoding]::ASCII.GetString($Bytes[0..20]) -match "<html|var ")) {
                        $EngineUsed = "Shellcode (Job)"
                        Invoke-SacrificialShellcode -FilePath $CurrentPath | Out-Null
                    }
                }
                
                if ($Status -eq "Success") { Write-Host "Executed: $(Split-Path $CurrentPath -Leaf) ($EngineUsed)" -ForegroundColor Green }

            } catch {
                $Status = "Failed Exec"; $ErrorDetail = $_.Exception.Message
                Write-Host "Failed: $(Split-Path $CurrentPath -Leaf) ($ErrorDetail)" -ForegroundColor Red
            }
        }
        $Report.Add([PSCustomObject]@{ FileName=$(Split-Path $CurrentPath -Leaf); Engine=$EngineUsed; Status=$Status })
        if ($ExecutionDelay -gt 0) { Start-Sleep -Seconds $ExecutionDelay }
    }

    # Helper: Link Clicker
    function Invoke-UrlVisits ($FilePath) {
        try {
            $Content = Get-Content $FilePath -Encoding Ascii -ErrorAction SilentlyContinue | Out-String
            $Links = [Regex]::Matches($Content, '(http|https)://([\w-]+\.)+[\w-]+(/[\w- ./?%&=]*)?') | Select-Object -ExpandProperty Value -Unique | Where-Object { -not (Test-IsLegitDomain $_) }
            if ($Links) {
                $Count = if ($Links.Count -gt $MaxLinksPerFile) { $MaxLinksPerFile } else { $Links.Count }
                Write-Host "    -> Clicking $Count links..." -ForegroundColor Magenta
                $Counter = 0
                foreach ($Link in $Links) {
                    if ($Counter -ge $MaxLinksPerFile) { break }
                    if ($BrowserBin) { Start-Process $BrowserBin -ArgumentList ($BrowserFlags + $Link) -ErrorAction SilentlyContinue }
                    Start-Sleep -Milliseconds 400; $Counter++
                }
            }
        } catch {}
    }

    # Noise Filters (Simplified for space - ensure Global:LegitDomains is defined if not persistent)
    if (-not $Global:LegitDomains) { $Global:LegitDomains = @("microsoft.com", "google.com") } 
    function Test-IsLegitDomain ($Url) { foreach ($d in $Global:LegitDomains) { if ($Url -match [Regex]::Escape($d)) { return $true } }; return $false }

    $Report | Export-Csv -Path (Join-Path $SamplesDir "Detonation_Report.csv") -NoTypeInformation
    Write-Host "`nCompleted." -ForegroundColor Green
}
Export-ModuleMember -Function Invoke-MalwareDetonation