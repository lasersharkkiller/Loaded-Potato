function Get-ListofVTSamplesBasedOnAPTsAndMalwareFamilies {
    <#
    .SYNOPSIS
        OFFLINE LIST BUILDER.
        Generates a deduplicated target list for the Downloader/Zipper script.
        
    .DESCRIPTION
        1. Accepts Target Names (APTs or Malware).
        2. Resolves linked tools via internal config.
        3. Scans your local 'apt\c6g' folder for the existing Master_Intel.csv files.
        4. FILTERS OUT:
           - Hashes you have already analyzed (Global_Hash_Resolution.csv).
           - Hashes known to be missing from VT (MissingHashes.csv).
        5. Exports 'ReadyForZip.csv'.

    .EXAMPLE
        Get-ListofVTSamplesBasedOnAPTsAndMalwareFamilies -Targets "UAT-8099"
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$false, Position=0)]
        [string[]]$Targets,

        [string]$IntelSourceDir = "apt\c6g",
        [string]$OutputFile = ".\ReadyForZip.csv",
        
        # Tracker Paths (for Exclusion)
        [string]$GlobalTrackerPath = "output\Global_Hash_Resolution.csv",
        [string]$MissingTrackerPath = "output\MissingHashes.csv"
    )

    # --- 1. INTERACTIVE PROMPT ---
    if (-not $Targets -or $Targets.Count -eq 0) {
        Write-Host "--- Offline Target Selection ---" -ForegroundColor Cyan
        Write-Host "Enter APTs or Malware Families to gather hashes for." -ForegroundColor Gray
        $InputStr = Read-Host "[?] Targets (comma separated)"
        if ([string]::IsNullOrWhiteSpace($InputStr)) { Write-Error "No targets provided."; return }
        $Targets = $InputStr -split "," | ForEach-Object { $_.Trim() }
    }

    # --- 2. CONFIGURATION (Relationships) ---
    # This maps "UAT-8099" -> "BadIIS", etc.
    $MasterConfig = @(
        # === CHINA ===
        @{ Name = "Velvet Ant"; LinkedTools = @("VelvetSting", "VelvetTap", "PlugX", "Impacket") },
        @{ Name = "Flax Typhoon"; LinkedTools = @("China Chopper", "JuicyPotato", "SoftEther") },
        @{ Name = "Volt Typhoon"; LinkedTools = @("KV-Botnet", "Impacket", "EarthWorm", "FastReverseProxy") },
        @{ Name = "APT41"; LinkedTools = @("ShadowPad", "Cobalt Strike", "Winnti") },
        @{ Name = "Mustang Panda"; LinkedTools = @("PlugX", "Cobalt Strike", "PDFSider") },
        @{ Name = "UAT-8099"; LinkedTools = @("BadIIS", "GotoHTTP", "Sharp4RemoveLog", "CnCrypt Protect") },
        
        # === NORTH KOREA ===
        @{ Name = "Lazarus"; LinkedTools = @("Manuscrypt", "MimiKatz") },
        @{ Name = "Konni Group"; LinkedTools = @("Konni RAT", "Amadey") },
        @{ Name = "Kimsuky"; LinkedTools = @("BabyShark", "AppleSeed") },

        # === RUSSIA ===
        @{ Name = "APT28"; LinkedTools = @("Mimikatz", "Impacket", "Chisel") },
        @{ Name = "Sandworm"; LinkedTools = @("DynoWiper", "BlackEnergy", "Industroyer") },

        # === E-CRIME ===
        @{ Name = "ShinyHunters"; LinkedTools = @("ShinySp1d3r", "Impacket") },
        @{ Name = "Scattered Spider"; LinkedTools = @("BlackCat", "Rubeus") },
        @{ Name = "Exotic Lily"; LinkedTools = @("Bumblebee", "IcedID") }
    )

    # --- 3. PATH RESOLUTION ---
    $CurrentDir = Get-Location
    function Get-Abs ($p) { if([System.IO.Path]::IsPathRooted($p)){return $p} return Join-Path $CurrentDir $p }
    
    $IntelSourceDir = Get-Abs $IntelSourceDir
    if (-not (Test-Path $IntelSourceDir)) { Write-Error "Intel Source Directory not found: $IntelSourceDir"; return }

    # --- 4. LOAD EXCLUSION LISTS ---
    $ExcludeSet = [System.Collections.Generic.HashSet[string]]::new()
    
    # A. Global Tracker (Already Analyzed)
    if (Test-Path $GlobalTrackerPath) {
        Write-Host "Loading Processed History..." -NoNewline
        $csv = Import-Csv $GlobalTrackerPath
        foreach ($row in $csv) {
            if ($row.Canonical_SHA256) { [void]$ExcludeSet.Add($row.Canonical_SHA256) }
            if ($row.Input_Hash) { [void]$ExcludeSet.Add($row.Input_Hash) }
        }
        Write-Host " $($ExcludeSet.Count) entries." -ForegroundColor Gray
    }

    # B. Missing Hashes (Known 404s)
    if (Test-Path $MissingTrackerPath) {
        Write-Host "Loading Known Missing Hashes (404s)..." -NoNewline
        $countStart = $ExcludeSet.Count
        $csv = Import-Csv $MissingTrackerPath
        foreach ($row in $csv) {
            if ($row.Hash) { [void]$ExcludeSet.Add($row.Hash) }
        }
        Write-Host " Added $($ExcludeSet.Count - $countStart) entries." -ForegroundColor Gray
    }

    # --- 5. BUILD SEARCH LIST ---
    $FilesToScan = @()
    
    foreach ($T in $Targets) {
        # 1. Look for the Target itself
        $FilesToScan += $T

        # 2. Look for Linked Tools
        $Entry = $MasterConfig | Where-Object { $_.Name -eq $T } | Select-Object -First 1
        if ($Entry -and $Entry.LinkedTools) {
            Write-Host "  -> Expanding '$T' to include: $($Entry.LinkedTools -join ', ')" -ForegroundColor Cyan
            $FilesToScan += $Entry.LinkedTools
        }
    }

    # --- 6. HARVEST LOCAL HASHES ---
    $CollectedHashes = [System.Collections.Generic.HashSet[string]]::new()
    Write-Host "`nScanning local folder '$IntelSourceDir' for CSVs..." -ForegroundColor Yellow

    foreach ($Name in $FilesToScan) {
        # Search recursively for the Master_Intel csv for this specific name
        # We use strict filtering on the filename to avoid grabbing the wrong group
        $Matches = Get-ChildItem -Path $IntelSourceDir -Recurse -Filter "${Name}_Master_Intel.csv" -ErrorAction SilentlyContinue
        
        if ($Matches) {
            foreach ($File in $Matches) {
                # Write-Host "  Reading: $($File.Name)" -ForegroundColor DarkGray
                $Data = Import-Csv $File.FullName
                foreach ($Row in $Data) {
                    $H = $Row.IOCValue
                    if (-not [string]::IsNullOrWhiteSpace($H)) {
                        # DEDUPLICATION & EXCLUSION LOGIC
                        if (-not $ExcludeSet.Contains($H)) {
                            [void]$CollectedHashes.Add($H)
                        }
                    }
                }
            }
        } else {
            Write-Warning "  No local intel file found for: $Name (Run the Harvester first?)"
        }
    }

    # --- 7. EXPORT ---
    if ($CollectedHashes.Count -gt 0) {
        $ExportData = $CollectedHashes | ForEach-Object { [PSCustomObject]@{ IOC = $_ } }
        $ExportData | Export-Csv -Path $OutputFile -NoTypeInformation -Encoding UTF8
        
        Write-Host "`nSuccess!" -ForegroundColor Green
        Write-Host "  Total Unique Hashes Found: $($CollectedHashes.Count)"
        Write-Host "  Excluded (Already Done/Missing): $($ExcludeSet.Count)"
        Write-Host "  Saved to: $OutputFile" -ForegroundColor Cyan
    } else {
        Write-Warning "No new hashes found. (Everything requested was either missing from disk or already in your exclusion lists)."
    }
}